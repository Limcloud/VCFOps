#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import json
import ssl
import sys
from urllib import request, error, parse

# ==========================
# CONFIGURACIÓN
# ==========================
BASE_URL = "https://vcf-ops-k1-01.vm.cloudidc.intranet.ice"

USERNAME = "user-helix"
PASSWORD = "H3l1x.@l3Rt.2025!"   # cámbialo si lo modifican

ALERT_DEFINITION_IDS = [
    "AlertDefinition-f8a6c9e1-f23a-4831-bf5d-b9071a37f8c3",
    "AlertDefinition-e6b21908-234b-475c-9244-822046b253d5",
    "AlertDefinition-b88c91b1-0176-4f96-9e0f-42ce9a631bab"
]

ACTIVE_ONLY = True
PAGE = 0
PAGE_SIZE = 1000

# ==========================
# UTILIDADES HTTP
# ==========================

# Contexto SSL sin validación de certificado (equivalente a curl -k)
SSL_CONTEXT = ssl._create_unverified_context()


def http_post(path, body_dict, headers=None, query_params=None):
    """
    Realiza un POST a BASE_URL + path, enviando body_dict como JSON.
    """
    if headers is None:
        headers = {}

    url = BASE_URL + path
    if query_params:
        qs = parse.urlencode(query_params)
        url = url + "?" + qs

    data = json.dumps(body_dict).encode("utf-8")
    req = request.Request(url, data=data, method="POST")

    # Headers básicos
    req.add_header("Content-Type", "application/json")
    for k, v in headers.items():
        req.add_header(k, v)

    try:
        with request.urlopen(req, context=SSL_CONTEXT) as resp:
            resp_data = resp.read().decode("utf-8")
            if not resp_data:
                return {}
            return json.loads(resp_data)
    except error.HTTPError as e:
        sys.stderr.write(f"HTTPError POST {url}: {e.code} {e.reason}\n")
        sys.stderr.write(e.read().decode("utf-8") + "\n")
        sys.exit(1)
    except error.URLError as e:
        sys.stderr.write(f"URLError POST {url}: {e.reason}\n")
        sys.exit(1)


def http_get(path, headers=None):
    """
    Realiza un GET a BASE_URL + path.
    """
    if headers is None:
        headers = {}

    url = BASE_URL + path
    req = request.Request(url, method="GET")
    for k, v in headers.items():
        req.add_header(k, v)

    try:
        with request.urlopen(req, context=SSL_CONTEXT) as resp:
            resp_data = resp.read().decode("utf-8")
            if not resp_data:
                return {}
            return json.loads(resp_data)
    except error.HTTPError as e:
        sys.stderr.write(f"HTTPError GET {url}: {e.code} {e.reason}\n")
        sys.stderr.write(e.read().decode("utf-8") + "\n")
        sys.exit(1)
    except error.URLError as e:
        sys.stderr.write(f"URLError GET {url}: {e.reason}\n")
        sys.exit(1)


# ==========================
# LÓGICA DE NEGOCIO
# ==========================

def acquire_token():
    """
    Llama a /suite-api/api/auth/token/acquire y devuelve el token.
    """
    path = "/suite-api/api/auth/token/acquire"
    body = {
        "username": USERNAME,
        "password": PASSWORD
    }
    resp = http_post(path, body)
    token = resp.get("token")
    if not token:
        sys.stderr.write("No se pudo obtener el token. Respuesta:\n")
        sys.stderr.write(json.dumps(resp, indent=2) + "\n")
        sys.exit(1)
    return token


def query_alerts(token):
    """
    Ejecuta el mismo query que tu curl actual a /alerts/query
    y devuelve el JSON completo.
    """
    path = "/suite-api/api/alerts/query"
    query_params = {
        "page": PAGE,
        "pageSize": PAGE_SIZE,
        "_no_links": "true"
    }
    headers = {
        "accept": "application/json",
        "Authorization": f"OpsToken {token}"
    }
    body = {
        "activeOnly": ACTIVE_ONLY,
        "alertDefinitionId": ALERT_DEFINITION_IDS,
        "page": PAGE,
        "pageSize": PAGE_SIZE
    }
    return http_post(path, body, headers=headers, query_params=query_params)


def get_resource_name(token, resource_id, cache):
    """
    Devuelve el nombre del recurso (resourceKey.name) para un resourceId.
    Usa una caché en memoria para evitar múltiples llamadas al mismo ID.
    """
    if resource_id in cache:
        return cache[resource_id]

    path = f"/suite-api/api/resources/{resource_id}"
    headers = {
        "accept": "application/json",
        "Authorization": f"OpsToken {token}"
    }
    resp = http_get(path, headers=headers)

    name = "N/A"
    try:
        name = resp.get("resourceKey", {}).get("name", "N/A")
    except Exception:
        pass

    cache[resource_id] = name
    return name


def main():
    # 1) Obtener token
    token = acquire_token()

    # 2) Consultar alertas
    alerts_json = query_alerts(token)

    page_info = alerts_json.get("pageInfo", {})
    alerts = alerts_json.get("alerts", [])

    if not alerts:
        # Devolver estructura vacía si no hay alertas
        result = {
            "pageInfo": page_info,
            "alerts": []
        }
        print(json.dumps(result, indent=2))
        return

    # 3) Enriquecer cada alerta con resourceName
    resource_cache = {}
    enriched_alerts = []

    for alert in alerts:
        resource_id = alert.get("resourceId")
        if not resource_id:
            # Si no tiene resourceId, lo dejamos igual
            enriched_alerts.append(alert)
            continue

        resource_name = get_resource_name(token, resource_id, resource_cache)

        # Clonar el dict de la alerta y agregar resourceName
        new_alert = dict(alert)
        new_alert["resourceName"] = resource_name
        enriched_alerts.append(new_alert)

    # 4) Armar JSON final
    result = {
        "pageInfo": page_info,
        "alerts": enriched_alerts
    }

    print(json.dumps(result, indent=2))


if __name__ == "__main__":
    main()
